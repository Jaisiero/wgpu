#version 460
#extension GL_EXT_ray_query : enable
// #extension GL_EXT_nonuniform_qualifier : require
#extension GL_ARB_shader_image_size : enable

// Output image at binding 0
layout(set = 0, binding = 0, rgba8) uniform image2D output_image;

// Uniform buffer for inverse view/projection matrices at binding 1
layout(set = 0, binding = 1) uniform Uniforms {
    mat4 view_inv;
    mat4 proj_inv;
} uniforms;

//Acceleration structure at binding 2
layout(set = 0, binding = 2) uniform accelerationStructureEXT acc_struct;

struct Aabb {
    vec3 _min;
    vec3 _max;
};

// Storage buffer for aabb data at binding 3
layout(set = 0, binding = 3) buffer AABBs { Aabb aabbs[]; };

uint query_loop(vec3 pos, vec3 dir, accelerationStructureEXT acs) {
    uint rayFlags = gl_RayFlagsNoneEXT;
    float tMin = 0.0001;
    float tMax = 10000.0;
    uint cullMask = 0xFF;
    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(
        rayQuery, acs,
        rayFlags,
        cullMask, // cullMask
        pos, tMin, dir, tMax);

    while (rayQueryProceedEXT(rayQuery))
    {
        uint type = rayQueryGetIntersectionTypeEXT(rayQuery, false);
        if (type == gl_RayQueryCandidateIntersectionAABBEXT)
        {
            rayQueryGenerateIntersectionEXT(rayQuery, tMax);
        }
    }

    return rayQueryGetIntersectionTypeEXT(rayQuery, true);
}

const vec4 CUBE_COLOR = vec4(0.0, 0.5, 1.0, 1.0);

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main() {
    ivec2 global_id = ivec2(gl_GlobalInvocationID.xy);
    ivec2 target_size = imageSize(output_image);

    if(global_id.x >= target_size.x || global_id.y >= target_size.y) {
        return;
    }

    vec4 color = vec4(vec2(global_id) / vec2(target_size), 0.0, 1.0);

    vec2 pixel_center = vec2(global_id) + vec2(0.5);
    vec2 in_uv = pixel_center / vec2(target_size);
    vec2 d = in_uv * 2.0 - 1.0;

    vec3 origin = (uniforms.view_inv * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    vec4 temp = uniforms.proj_inv * vec4(d.x, d.y, 1.0, 1.0);
    vec3 direction = (uniforms.view_inv * vec4(normalize(temp.xyz), 0.0)).xyz;

    uint type = query_loop(origin, direction, acc_struct);

    if (type == gl_RayQueryCommittedIntersectionGeneratedEXT)
    {
        color = CUBE_COLOR;
    }

    imageStore(output_image, global_id, color);
}